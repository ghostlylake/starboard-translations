/* eslint-disable @typescript-eslint/strict-boolean-expressions */
/* eslint-disable @typescript-eslint/no-var-requires */
require("./validate")
const { parse, TYPE } = require("@formatjs/icu-messageformat-parser")
const { writeFileSync } = require("fs")
const messages = require("../translations/en-GB")
const primitives = ["string", "number", "true", "false", "boolean", "null"]

let res = [] // `export = {}`

const parseNode = node => {
  switch (node.type) {
    case TYPE.argument:
      return ["string"]
    case TYPE.number:
    case TYPE.plural:
      return ["number"]
    case TYPE.date:
    case TYPE.time:
      return ["Date", "number"]
    case TYPE.select: {
      const options = Object.keys(node.options)
      const values = new Set()
      for (const e of options) {
        if (e === "other") {
          // arg can be used inside the `other` clause, let's check for that
          const inner = node.options[e].value.slice()
          flattenAST(inner)
          let types = new Set()
          for (const innerReference of inner.filter(innerNode => innerNode.value === node.value)) {
            switch (innerReference.type) {
              case TYPE.argument:
                types.add("string")
                break
              case TYPE.number:
              case TYPE.plural:
                types.add("number")
                break
              case TYPE.date:
              case TYPE.time:
                types.add("Date | number")
                break
            }
          }
          values.add(Array.from(types).join(" | ") || "string")
        }
        else if (!isNaN(e)) values.add("number")
        else if (e === "null") values.add("null")
        else if ((e === "true" || e === "false") && !values.has("boolean")) {
          values.add(e)
          if (values.has("true") && values.has("false")) {
            values.delete("true")
            values.delete("false")
            values.add("boolean")
          }
        }
        else values.add(`"${e}"`)
      }
      return values
    }
  }
}

const flattenAST = ast => {
  for (const node of ast)
    if (node.type === TYPE.select || node.type === TYPE.plural)
      for (const option of Object.values(node.options))
        for (const child of option.value) {
          const temp = [child]
          flattenAST(temp)
          ast.push(...temp)
        }
}

const iterate = (obj, key = "") => {
  for (const i in obj) {
    const str = Array.isArray(obj[i]) ? obj[i].join("") : obj[i]
    if (typeof str === "object") iterate(str, key + i + ".")
    else if (typeof str === "string" && str.includes("{")) {
      let obj = {}
      let ast
      try {
        ast = parse(str, { ignoreTag: true, requiresOtherClause: false })
      } catch (error) {
        const { location } = error
        console.error(`Invalid translation for ${key}${i}:`)
        if (location.start.line !== location.end.line) throw error
        else {
          let e = new error.constructor(`${error}\n\n${str.replace("\n", " ")}\n${" ".repeat(location.start.offset)}${"~".repeat(location.end.offset - location.start.offset)}`)
          throw e
        }
      }
      flattenAST(ast)

      for (const node of ast) {
        const values = parseNode(node)
        if (!values) continue
        const list = obj[node.value] ??= []
        list.push(...values)
      }

      const types = Object.entries(obj)
        .map(([key, v]) => {
          const hasLiteral = v.some(val => val.includes("\""))
          const value =
            [...new Set(v)]
              .map(v => hasLiteral && v === "string" ? "OtherString" : v)
              .sort((a, b) => {
                if (a === "OtherString") return +1
                else if (b === "OtherString") return -1
                const primSort = primitives.indexOf(a) - primitives.indexOf(b)
                if (primSort) return primSort
                const alph = [a, b].sort()
                return alph.indexOf(a) - alph.indexOf(b)
              })
              .join(" | ") || "unknown"
          return `${key}: ${value},`
        })
        .join("\n    ")

      res.push(`"${key + i}": {\n    ${types}\n  },`)
    }
  }
}
iterate(messages)

writeFileSync("./types.d.ts", `
// auto generated by ./scripts/types.js

type OtherString = string & {}
declare type MessageParameters = {
  ${res.join("\n  ")}
}

export = MessageParameters
`.trim())
console.log(`Wrote types for ${res.length} translations. (../types.d.ts)`)